//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class AircraftServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update Aircraft
     * @return OK
     */
    updateAircraft(body: EditAircraftDto, signal?: AbortSignal): Promise<UpdateAircraftResult> {
        let url_ = this.baseUrl + "/api/v1/flight/aircraft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAircraft(_response);
        });
    }

    protected processUpdateAircraft(response: AxiosResponse): Promise<UpdateAircraftResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateAircraftResult.fromJS(resultData200);
            return Promise.resolve<UpdateAircraftResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateAircraftResult>(null as any);
    }

    /**
     * Create New Air Craft
     * @return OK
     */
    createAircraft(body: CreateAircraftDto, signal?: AbortSignal): Promise<CreateAircraftResult> {
        let url_ = this.baseUrl + "/api/v1/flight/aircraft";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAircraft(_response);
        });
    }

    protected processCreateAircraft(response: AxiosResponse): Promise<CreateAircraftResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateAircraftResult.fromJS(resultData200);
            return Promise.resolve<CreateAircraftResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateAircraftResult>(null as any);
    }

    /**
     * Get Paginated Aircrafts
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getAircrafts(skipCount: number, maxResultCount: number, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetAircraftsResult> {
        let url_ = this.baseUrl + "/api/v1/flight/aircrafts?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAircrafts(_response);
        });
    }

    protected processGetAircrafts(response: AxiosResponse): Promise<GetAircraftsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAircraftsResult.fromJS(resultData200);
            return Promise.resolve<GetAircraftsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAircraftsResult>(null as any);
    }

    /**
     * Get Aircraft By Id
     * @return OK
     */
    getAircraftById(aircraftid: string, signal?: AbortSignal): Promise<GetAircraftByIdResult> {
        let url_ = this.baseUrl + "/api/v1/flight/aircraft/{aircraftid}";
        if (aircraftid === undefined || aircraftid === null)
            throw new Error("The parameter 'aircraftid' must be defined.");
        url_ = url_.replace("{aircraftid}", encodeURIComponent("" + aircraftid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAircraftById(_response);
        });
    }

    protected processGetAircraftById(response: AxiosResponse): Promise<GetAircraftByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAircraftByIdResult.fromJS(resultData200);
            return Promise.resolve<GetAircraftByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAircraftByIdResult>(null as any);
    }

    /**
     * Delete Aircraft
     */
    deleteAircraft(aircraftid: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/flight/aircraft/{aircraftid}";
        if (aircraftid === undefined || aircraftid === null)
            throw new Error("The parameter 'aircraftid' must be defined.");
        url_ = url_.replace("{aircraftid}", encodeURIComponent("" + aircraftid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAircraft(_response);
        });
    }

    protected processDeleteAircraft(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AirportServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update Airport
     * @return OK
     */
    updateAirport(body: EditAirportDto, signal?: AbortSignal): Promise<UpdateAirportResult> {
        let url_ = this.baseUrl + "/api/v1/flight/airport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAirport(_response);
        });
    }

    protected processUpdateAirport(response: AxiosResponse): Promise<UpdateAirportResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateAirportResult.fromJS(resultData200);
            return Promise.resolve<UpdateAirportResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateAirportResult>(null as any);
    }

    /**
     * Create New Airport
     * @return OK
     */
    createAirport(body: CreateAirportDto, signal?: AbortSignal): Promise<CreateAirportResult> {
        let url_ = this.baseUrl + "/api/v1/flight/airport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAirport(_response);
        });
    }

    protected processCreateAirport(response: AxiosResponse): Promise<CreateAirportResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateAirportResult.fromJS(resultData200);
            return Promise.resolve<CreateAirportResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateAirportResult>(null as any);
    }

    /**
     * Get Paginated Airports
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getAirports(skipCount: number, maxResultCount: number, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetAirportsResult> {
        let url_ = this.baseUrl + "/api/v1/flight/airports?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAirports(_response);
        });
    }

    protected processGetAirports(response: AxiosResponse): Promise<GetAirportsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAirportsResult.fromJS(resultData200);
            return Promise.resolve<GetAirportsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAirportsResult>(null as any);
    }

    /**
     * Get Airport By Id
     * @return OK
     */
    getAirportById(airportid: number, signal?: AbortSignal): Promise<GetAirportByIdResult> {
        let url_ = this.baseUrl + "/api/v1/flight/airport/{airportid}";
        if (airportid === undefined || airportid === null)
            throw new Error("The parameter 'airportid' must be defined.");
        url_ = url_.replace("{airportid}", encodeURIComponent("" + airportid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAirportById(_response);
        });
    }

    protected processGetAirportById(response: AxiosResponse): Promise<GetAirportByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAirportByIdResult.fromJS(resultData200);
            return Promise.resolve<GetAirportByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAirportByIdResult>(null as any);
    }

    /**
     * Delete Airport
     */
    deleteAirport(airportid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/flight/airport/{airportid}";
        if (airportid === undefined || airportid === null)
            throw new Error("The parameter 'airportid' must be defined.");
        url_ = url_.replace("{airportid}", encodeURIComponent("" + airportid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAirport(_response);
        });
    }

    protected processDeleteAirport(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class FlightServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update Flight
     * @return OK
     */
    updateFlight(body: EditFlightDto, signal?: AbortSignal): Promise<UpdateFlightResult> {
        let url_ = this.baseUrl + "/api/v1/flight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFlight(_response);
        });
    }

    protected processUpdateFlight(response: AxiosResponse): Promise<UpdateFlightResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateFlightResult.fromJS(resultData200);
            return Promise.resolve<UpdateFlightResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateFlightResult>(null as any);
    }

    /**
     * Create New Flight
     * @return OK
     */
    createFlight(body: CreateFlightDto, signal?: AbortSignal): Promise<CreateFlightResult> {
        let url_ = this.baseUrl + "/api/v1/flight";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFlight(_response);
        });
    }

    protected processCreateFlight(response: AxiosResponse): Promise<CreateFlightResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateFlightResult.fromJS(resultData200);
            return Promise.resolve<CreateFlightResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateFlightResult>(null as any);
    }

    /**
     * Get Paginated Flights
     * @param minPriceFilter (optional) 
     * @param maxPriceFilter (optional) 
     * @param aircraftIdFilter (optional) 
     * @param departureAirportIdFilter (optional) 
     * @param arrivalAirportIdFilter (optional) 
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getFlights(minPriceFilter: number | undefined, maxPriceFilter: number | undefined, aircraftIdFilter: string | undefined, departureAirportIdFilter: number | undefined, arrivalAirportIdFilter: number | undefined, skipCount: number, maxResultCount: number, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetFlightsResult> {
        let url_ = this.baseUrl + "/api/v1/flight/flights?";
        if (minPriceFilter === null)
            throw new Error("The parameter 'minPriceFilter' cannot be null.");
        else if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&";
        if (maxPriceFilter === null)
            throw new Error("The parameter 'maxPriceFilter' cannot be null.");
        else if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&";
        if (aircraftIdFilter === null)
            throw new Error("The parameter 'aircraftIdFilter' cannot be null.");
        else if (aircraftIdFilter !== undefined)
            url_ += "AircraftIdFilter=" + encodeURIComponent("" + aircraftIdFilter) + "&";
        if (departureAirportIdFilter === null)
            throw new Error("The parameter 'departureAirportIdFilter' cannot be null.");
        else if (departureAirportIdFilter !== undefined)
            url_ += "DepartureAirportIdFilter=" + encodeURIComponent("" + departureAirportIdFilter) + "&";
        if (arrivalAirportIdFilter === null)
            throw new Error("The parameter 'arrivalAirportIdFilter' cannot be null.");
        else if (arrivalAirportIdFilter !== undefined)
            url_ += "ArrivalAirportIdFilter=" + encodeURIComponent("" + arrivalAirportIdFilter) + "&";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFlights(_response);
        });
    }

    protected processGetFlights(response: AxiosResponse): Promise<GetFlightsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetFlightsResult.fromJS(resultData200);
            return Promise.resolve<GetFlightsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetFlightsResult>(null as any);
    }

    /**
     * Get Flight By Id
     * @return OK
     */
    getFlightById(flightid: number, signal?: AbortSignal): Promise<GetFlightByIdResult> {
        let url_ = this.baseUrl + "/api/v1/flight/{flightid}";
        if (flightid === undefined || flightid === null)
            throw new Error("The parameter 'flightid' must be defined.");
        url_ = url_.replace("{flightid}", encodeURIComponent("" + flightid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFlightById(_response);
        });
    }

    protected processGetFlightById(response: AxiosResponse): Promise<GetFlightByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetFlightByIdResult.fromJS(resultData200);
            return Promise.resolve<GetFlightByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetFlightByIdResult>(null as any);
    }

    /**
     * Delete Flight
     */
    deleteFlight(flightid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/flight/{flightid}";
        if (flightid === undefined || flightid === null)
            throw new Error("The parameter 'flightid' must be defined.");
        url_ = url_.replace("{flightid}", encodeURIComponent("" + flightid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteFlight(_response);
        });
    }

    protected processDeleteFlight(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class SeatServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update Seat
     * @return OK
     */
    updateSeat(body: UpdateSeatRequest, signal?: AbortSignal): Promise<UpdateSeatResponse> {
        let url_ = this.baseUrl + "/api/v1/seat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSeat(_response);
        });
    }

    protected processUpdateSeat(response: AxiosResponse): Promise<UpdateSeatResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateSeatResponse.fromJS(resultData200);
            return Promise.resolve<UpdateSeatResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateSeatResponse>(null as any);
    }

    /**
     * Create New Seat
     * @return OK
     */
    createSeat(body: CreateSeatRequest, signal?: AbortSignal): Promise<CreateSeatResponse> {
        let url_ = this.baseUrl + "/api/v1/seat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSeat(_response);
        });
    }

    protected processCreateSeat(response: AxiosResponse): Promise<CreateSeatResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateSeatResponse.fromJS(resultData200);
            return Promise.resolve<CreateSeatResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateSeatResponse>(null as any);
    }

    /**
     * Get Paginated Seats
     * @param flightIdFilter (optional) 
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getSeats(flightIdFilter: number | undefined, skipCount: number, maxResultCount: number, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetSeatsResult> {
        let url_ = this.baseUrl + "/api/v1/seats?";
        if (flightIdFilter === null)
            throw new Error("The parameter 'flightIdFilter' cannot be null.");
        else if (flightIdFilter !== undefined)
            url_ += "FlightIdFilter=" + encodeURIComponent("" + flightIdFilter) + "&";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSeats(_response);
        });
    }

    protected processGetSeats(response: AxiosResponse): Promise<GetSeatsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetSeatsResult.fromJS(resultData200);
            return Promise.resolve<GetSeatsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSeatsResult>(null as any);
    }

    /**
     * Get Seat By Id
     * @return OK
     */
    getSeatById(seatid: number, signal?: AbortSignal): Promise<GetSeatByIdResult> {
        let url_ = this.baseUrl + "/api/v1/seat/{seatid}";
        if (seatid === undefined || seatid === null)
            throw new Error("The parameter 'seatid' must be defined.");
        url_ = url_.replace("{seatid}", encodeURIComponent("" + seatid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSeatById(_response);
        });
    }

    protected processGetSeatById(response: AxiosResponse): Promise<GetSeatByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetSeatByIdResult.fromJS(resultData200);
            return Promise.resolve<GetSeatByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetSeatByIdResult>(null as any);
    }

    /**
     * Delete Seat
     */
    deleteSeat(seatid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/seat/{seatid}";
        if (seatid === undefined || seatid === null)
            throw new Error("The parameter 'seatid' must be defined.");
        url_ = url_.replace("{seatid}", encodeURIComponent("" + seatid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteSeat(_response);
        });
    }

    protected processDeleteSeat(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AircraftDto implements IAircraftDto {
    id!: string;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    name!: string | undefined;
    model!: string | undefined;
    manufacturingYear!: number;

    constructor(data?: IAircraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.model = _data["model"];
            this.manufacturingYear = _data["manufacturingYear"];
        }
    }

    static fromJS(data: any): AircraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new AircraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["model"] = this.model;
        data["manufacturingYear"] = this.manufacturingYear;
        return data;
    }

    clone(): AircraftDto {
        const json = this.toJSON();
        let result = new AircraftDto();
        result.init(json);
        return result;
    }
}

export interface IAircraftDto {
    id: string;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    name: string | undefined;
    model: string | undefined;
    manufacturingYear: number;
}

export class AirportDto implements IAirportDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;

    constructor(data?: IAirportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): AirportDto {
        data = typeof data === 'object' ? data : {};
        let result = new AirportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        return data;
    }

    clone(): AirportDto {
        const json = this.toJSON();
        let result = new AirportDto();
        result.init(json);
        return result;
    }
}

export interface IAirportDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
}

export class CreateAircraftDto implements ICreateAircraftDto {
    id!: string;
    name!: string | undefined;
    model!: string | undefined;
    manufacturingYear!: number;

    constructor(data?: ICreateAircraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.manufacturingYear = _data["manufacturingYear"];
        }
    }

    static fromJS(data: any): CreateAircraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAircraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["model"] = this.model;
        data["manufacturingYear"] = this.manufacturingYear;
        return data;
    }

    clone(): CreateAircraftDto {
        const json = this.toJSON();
        let result = new CreateAircraftDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAircraftDto {
    id: string;
    name: string | undefined;
    model: string | undefined;
    manufacturingYear: number;
}

export class CreateAircraftResult implements ICreateAircraftResult {
    aircraft!: AircraftDto;

    constructor(data?: ICreateAircraftResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aircraft = _data["aircraft"] ? AircraftDto.fromJS(_data["aircraft"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateAircraftResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAircraftResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aircraft"] = this.aircraft ? this.aircraft.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateAircraftResult {
        const json = this.toJSON();
        let result = new CreateAircraftResult();
        result.init(json);
        return result;
    }
}

export interface ICreateAircraftResult {
    aircraft: AircraftDto;
}

export class CreateAirportDto implements ICreateAirportDto {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;

    constructor(data?: ICreateAirportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CreateAirportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAirportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        return data;
    }

    clone(): CreateAirportDto {
        const json = this.toJSON();
        let result = new CreateAirportDto();
        result.init(json);
        return result;
    }
}

export interface ICreateAirportDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
}

export class CreateAirportResult implements ICreateAirportResult {
    airport!: AirportDto;

    constructor(data?: ICreateAirportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airport = _data["airport"] ? AirportDto.fromJS(_data["airport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateAirportResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAirportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airport"] = this.airport ? this.airport.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateAirportResult {
        const json = this.toJSON();
        let result = new CreateAirportResult();
        result.init(json);
        return result;
    }
}

export interface ICreateAirportResult {
    airport: AirportDto;
}

export class CreateFlightDto implements ICreateFlightDto {
    id!: number;
    flightNo!: string | undefined;
    price!: number;
    durationMinutes!: number;
    departureDate!: moment.Moment;
    arrivalDate!: moment.Moment;
    aircraftId!: string | undefined;
    departureAirportId!: number | undefined;
    arrivalAirportId!: number | undefined;

    constructor(data?: ICreateFlightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightNo = _data["flightNo"];
            this.price = _data["price"];
            this.durationMinutes = _data["durationMinutes"];
            this.departureDate = _data["departureDate"] ? moment(_data["departureDate"].toString()) : <any>undefined;
            this.arrivalDate = _data["arrivalDate"] ? moment(_data["arrivalDate"].toString()) : <any>undefined;
            this.aircraftId = _data["aircraftId"];
            this.departureAirportId = _data["departureAirportId"];
            this.arrivalAirportId = _data["arrivalAirportId"];
        }
    }

    static fromJS(data: any): CreateFlightDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFlightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightNo"] = this.flightNo;
        data["price"] = this.price;
        data["durationMinutes"] = this.durationMinutes;
        data["departureDate"] = this.departureDate ? this.departureDate.toISOString() : <any>undefined;
        data["arrivalDate"] = this.arrivalDate ? this.arrivalDate.toISOString() : <any>undefined;
        data["aircraftId"] = this.aircraftId;
        data["departureAirportId"] = this.departureAirportId;
        data["arrivalAirportId"] = this.arrivalAirportId;
        return data;
    }

    clone(): CreateFlightDto {
        const json = this.toJSON();
        let result = new CreateFlightDto();
        result.init(json);
        return result;
    }
}

export interface ICreateFlightDto {
    id: number;
    flightNo: string | undefined;
    price: number;
    durationMinutes: number;
    departureDate: moment.Moment;
    arrivalDate: moment.Moment;
    aircraftId: string | undefined;
    departureAirportId: number | undefined;
    arrivalAirportId: number | undefined;
}

export class CreateFlightResult implements ICreateFlightResult {
    flight!: FlightDto;

    constructor(data?: ICreateFlightResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flight = _data["flight"] ? FlightDto.fromJS(_data["flight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateFlightResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFlightResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flight"] = this.flight ? this.flight.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateFlightResult {
        const json = this.toJSON();
        let result = new CreateFlightResult();
        result.init(json);
        return result;
    }
}

export interface ICreateFlightResult {
    flight: FlightDto;
}

export class CreateOrEditAircraftDto implements ICreateOrEditAircraftDto {
    id!: string;
    name!: string | undefined;
    model!: string | undefined;
    manufacturingYear!: number;

    constructor(data?: ICreateOrEditAircraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.manufacturingYear = _data["manufacturingYear"];
        }
    }

    static fromJS(data: any): CreateOrEditAircraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAircraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["model"] = this.model;
        data["manufacturingYear"] = this.manufacturingYear;
        return data;
    }

    clone(): CreateOrEditAircraftDto {
        const json = this.toJSON();
        let result = new CreateOrEditAircraftDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditAircraftDto {
    id: string;
    name: string | undefined;
    model: string | undefined;
    manufacturingYear: number;
}

export class CreateOrEditAirportDto implements ICreateOrEditAirportDto {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;

    constructor(data?: ICreateOrEditAirportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): CreateOrEditAirportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAirportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        return data;
    }

    clone(): CreateOrEditAirportDto {
        const json = this.toJSON();
        let result = new CreateOrEditAirportDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditAirportDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
}

export class CreateOrEditFlightDto implements ICreateOrEditFlightDto {
    id!: number;
    flightNo!: string | undefined;
    price!: number;
    durationMinutes!: number;
    departureDate!: moment.Moment;
    arrivalDate!: moment.Moment;
    aircraftId!: string | undefined;
    departureAirportId!: number | undefined;
    arrivalAirportId!: number | undefined;

    constructor(data?: ICreateOrEditFlightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightNo = _data["flightNo"];
            this.price = _data["price"];
            this.durationMinutes = _data["durationMinutes"];
            this.departureDate = _data["departureDate"] ? moment(_data["departureDate"].toString()) : <any>undefined;
            this.arrivalDate = _data["arrivalDate"] ? moment(_data["arrivalDate"].toString()) : <any>undefined;
            this.aircraftId = _data["aircraftId"];
            this.departureAirportId = _data["departureAirportId"];
            this.arrivalAirportId = _data["arrivalAirportId"];
        }
    }

    static fromJS(data: any): CreateOrEditFlightDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditFlightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightNo"] = this.flightNo;
        data["price"] = this.price;
        data["durationMinutes"] = this.durationMinutes;
        data["departureDate"] = this.departureDate ? this.departureDate.toISOString() : <any>undefined;
        data["arrivalDate"] = this.arrivalDate ? this.arrivalDate.toISOString() : <any>undefined;
        data["aircraftId"] = this.aircraftId;
        data["departureAirportId"] = this.departureAirportId;
        data["arrivalAirportId"] = this.arrivalAirportId;
        return data;
    }

    clone(): CreateOrEditFlightDto {
        const json = this.toJSON();
        let result = new CreateOrEditFlightDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditFlightDto {
    id: number;
    flightNo: string | undefined;
    price: number;
    durationMinutes: number;
    departureDate: moment.Moment;
    arrivalDate: moment.Moment;
    aircraftId: string | undefined;
    departureAirportId: number | undefined;
    arrivalAirportId: number | undefined;
}

export class CreateSeatRequest implements ICreateSeatRequest {
    seatNo!: string | undefined;
    class!: SeatClass;
    type!: SeatType;
    flightId!: number | undefined;

    constructor(data?: ICreateSeatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seatNo = _data["seatNo"];
            this.class = _data["class"];
            this.type = _data["type"];
            this.flightId = _data["flightId"];
        }
    }

    static fromJS(data: any): CreateSeatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSeatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seatNo"] = this.seatNo;
        data["class"] = this.class;
        data["type"] = this.type;
        data["flightId"] = this.flightId;
        return data;
    }

    clone(): CreateSeatRequest {
        const json = this.toJSON();
        let result = new CreateSeatRequest();
        result.init(json);
        return result;
    }
}

export interface ICreateSeatRequest {
    seatNo: string | undefined;
    class: SeatClass;
    type: SeatType;
    flightId: number | undefined;
}

export class CreateSeatResponse implements ICreateSeatResponse {
    seat!: SeatDto;

    constructor(data?: ICreateSeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seat = _data["seat"] ? SeatDto.fromJS(_data["seat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateSeatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSeatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seat"] = this.seat ? this.seat.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateSeatResponse {
        const json = this.toJSON();
        let result = new CreateSeatResponse();
        result.init(json);
        return result;
    }
}

export interface ICreateSeatResponse {
    seat: SeatDto;
}

export class EditAircraftDto implements IEditAircraftDto {
    id!: string;
    name!: string | undefined;
    model!: string | undefined;
    manufacturingYear!: number;

    constructor(data?: IEditAircraftDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.model = _data["model"];
            this.manufacturingYear = _data["manufacturingYear"];
        }
    }

    static fromJS(data: any): EditAircraftDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditAircraftDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["model"] = this.model;
        data["manufacturingYear"] = this.manufacturingYear;
        return data;
    }

    clone(): EditAircraftDto {
        const json = this.toJSON();
        let result = new EditAircraftDto();
        result.init(json);
        return result;
    }
}

export interface IEditAircraftDto {
    id: string;
    name: string | undefined;
    model: string | undefined;
    manufacturingYear: number;
}

export class EditAirportDto implements IEditAirportDto {
    id!: number;
    name!: string | undefined;
    code!: string | undefined;
    address!: string | undefined;

    constructor(data?: IEditAirportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): EditAirportDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditAirportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["address"] = this.address;
        return data;
    }

    clone(): EditAirportDto {
        const json = this.toJSON();
        let result = new EditAirportDto();
        result.init(json);
        return result;
    }
}

export interface IEditAirportDto {
    id: number;
    name: string | undefined;
    code: string | undefined;
    address: string | undefined;
}

export class EditFlightDto implements IEditFlightDto {
    id!: number;
    flightNo!: string | undefined;
    price!: number;
    durationMinutes!: number;
    departureDate!: moment.Moment;
    arrivalDate!: moment.Moment;
    aircraftId!: string | undefined;
    departureAirportId!: number | undefined;
    arrivalAirportId!: number | undefined;

    constructor(data?: IEditFlightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.flightNo = _data["flightNo"];
            this.price = _data["price"];
            this.durationMinutes = _data["durationMinutes"];
            this.departureDate = _data["departureDate"] ? moment(_data["departureDate"].toString()) : <any>undefined;
            this.arrivalDate = _data["arrivalDate"] ? moment(_data["arrivalDate"].toString()) : <any>undefined;
            this.aircraftId = _data["aircraftId"];
            this.departureAirportId = _data["departureAirportId"];
            this.arrivalAirportId = _data["arrivalAirportId"];
        }
    }

    static fromJS(data: any): EditFlightDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditFlightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["flightNo"] = this.flightNo;
        data["price"] = this.price;
        data["durationMinutes"] = this.durationMinutes;
        data["departureDate"] = this.departureDate ? this.departureDate.toISOString() : <any>undefined;
        data["arrivalDate"] = this.arrivalDate ? this.arrivalDate.toISOString() : <any>undefined;
        data["aircraftId"] = this.aircraftId;
        data["departureAirportId"] = this.departureAirportId;
        data["arrivalAirportId"] = this.arrivalAirportId;
        return data;
    }

    clone(): EditFlightDto {
        const json = this.toJSON();
        let result = new EditFlightDto();
        result.init(json);
        return result;
    }
}

export interface IEditFlightDto {
    id: number;
    flightNo: string | undefined;
    price: number;
    durationMinutes: number;
    departureDate: moment.Moment;
    arrivalDate: moment.Moment;
    aircraftId: string | undefined;
    departureAirportId: number | undefined;
    arrivalAirportId: number | undefined;
}

export class FlightDto implements IFlightDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    flightNo!: string | undefined;
    price!: number;
    durationMinutes!: number;
    status!: FlightStatus;
    departureDate!: moment.Moment;
    arrivalDate!: moment.Moment;
    aircraftId!: string | undefined;
    aircraftName!: string | undefined;
    departureAirportId!: number | undefined;
    departureAirportName!: string | undefined;
    arrivalAirportId!: number | undefined;
    arrivalAirportName!: string | undefined;

    constructor(data?: IFlightDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.flightNo = _data["flightNo"];
            this.price = _data["price"];
            this.durationMinutes = _data["durationMinutes"];
            this.status = _data["status"];
            this.departureDate = _data["departureDate"] ? moment(_data["departureDate"].toString()) : <any>undefined;
            this.arrivalDate = _data["arrivalDate"] ? moment(_data["arrivalDate"].toString()) : <any>undefined;
            this.aircraftId = _data["aircraftId"];
            this.aircraftName = _data["aircraftName"];
            this.departureAirportId = _data["departureAirportId"];
            this.departureAirportName = _data["departureAirportName"];
            this.arrivalAirportId = _data["arrivalAirportId"];
            this.arrivalAirportName = _data["arrivalAirportName"];
        }
    }

    static fromJS(data: any): FlightDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlightDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["flightNo"] = this.flightNo;
        data["price"] = this.price;
        data["durationMinutes"] = this.durationMinutes;
        data["status"] = this.status;
        data["departureDate"] = this.departureDate ? this.departureDate.toISOString() : <any>undefined;
        data["arrivalDate"] = this.arrivalDate ? this.arrivalDate.toISOString() : <any>undefined;
        data["aircraftId"] = this.aircraftId;
        data["aircraftName"] = this.aircraftName;
        data["departureAirportId"] = this.departureAirportId;
        data["departureAirportName"] = this.departureAirportName;
        data["arrivalAirportId"] = this.arrivalAirportId;
        data["arrivalAirportName"] = this.arrivalAirportName;
        return data;
    }

    clone(): FlightDto {
        const json = this.toJSON();
        let result = new FlightDto();
        result.init(json);
        return result;
    }
}

export interface IFlightDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    flightNo: string | undefined;
    price: number;
    durationMinutes: number;
    status: FlightStatus;
    departureDate: moment.Moment;
    arrivalDate: moment.Moment;
    aircraftId: string | undefined;
    aircraftName: string | undefined;
    departureAirportId: number | undefined;
    departureAirportName: string | undefined;
    arrivalAirportId: number | undefined;
    arrivalAirportName: string | undefined;
}

/** 0 = Unknown 1 = Flying 2 = Delay 3 = Canceled 4 = Completed */
export enum FlightStatus {
    Unknown = 0,
    Flying = 1,
    Delay = 2,
    Canceled = 3,
    Completed = 4,
}

export class GetAircraftByIdResult implements IGetAircraftByIdResult {
    aircraft!: CreateOrEditAircraftDto;

    constructor(data?: IGetAircraftByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aircraft = _data["aircraft"] ? CreateOrEditAircraftDto.fromJS(_data["aircraft"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAircraftByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAircraftByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aircraft"] = this.aircraft ? this.aircraft.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetAircraftByIdResult {
        const json = this.toJSON();
        let result = new GetAircraftByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetAircraftByIdResult {
    aircraft: CreateOrEditAircraftDto;
}

export class GetAircraftsResult implements IGetAircraftsResult {
    items!: AircraftDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAircraftsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AircraftDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAircraftsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAircraftsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetAircraftsResult {
        const json = this.toJSON();
        let result = new GetAircraftsResult();
        result.init(json);
        return result;
    }
}

export interface IGetAircraftsResult {
    items: AircraftDto[] | undefined;
    totalCount: number;
}

export class GetAirportByIdResult implements IGetAirportByIdResult {
    airport!: CreateOrEditAirportDto;

    constructor(data?: IGetAirportByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airport = _data["airport"] ? CreateOrEditAirportDto.fromJS(_data["airport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAirportByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAirportByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airport"] = this.airport ? this.airport.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetAirportByIdResult {
        const json = this.toJSON();
        let result = new GetAirportByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetAirportByIdResult {
    airport: CreateOrEditAirportDto;
}

export class GetAirportsResult implements IGetAirportsResult {
    items!: AirportDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAirportsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AirportDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAirportsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAirportsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetAirportsResult {
        const json = this.toJSON();
        let result = new GetAirportsResult();
        result.init(json);
        return result;
    }
}

export interface IGetAirportsResult {
    items: AirportDto[] | undefined;
    totalCount: number;
}

export class GetFlightByIdResult implements IGetFlightByIdResult {
    flight!: CreateOrEditFlightDto;

    constructor(data?: IGetFlightByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flight = _data["flight"] ? CreateOrEditFlightDto.fromJS(_data["flight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFlightByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetFlightByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flight"] = this.flight ? this.flight.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetFlightByIdResult {
        const json = this.toJSON();
        let result = new GetFlightByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetFlightByIdResult {
    flight: CreateOrEditFlightDto;
}

export class GetFlightsResult implements IGetFlightsResult {
    items!: FlightDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetFlightsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlightDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetFlightsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetFlightsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetFlightsResult {
        const json = this.toJSON();
        let result = new GetFlightsResult();
        result.init(json);
        return result;
    }
}

export interface IGetFlightsResult {
    items: FlightDto[] | undefined;
    totalCount: number;
}

export class GetSeatByIdResult implements IGetSeatByIdResult {
    seat!: SeatDto;

    constructor(data?: IGetSeatByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seat = _data["seat"] ? SeatDto.fromJS(_data["seat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSeatByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seat"] = this.seat ? this.seat.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetSeatByIdResult {
        const json = this.toJSON();
        let result = new GetSeatByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetSeatByIdResult {
    seat: SeatDto;
}

export class GetSeatsResult implements IGetSeatsResult {
    seats!: SeatDtoPagedResultDto;

    constructor(data?: IGetSeatsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seats = _data["seats"] ? SeatDtoPagedResultDto.fromJS(_data["seats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSeatsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetSeatsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seats"] = this.seats ? this.seats.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetSeatsResult {
        const json = this.toJSON();
        let result = new GetSeatsResult();
        result.init(json);
        return result;
    }
}

export interface IGetSeatsResult {
    seats: SeatDtoPagedResultDto;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }

    clone(): ProblemDetails {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

/** 0 = Unknown 1 = FirstClass 2 = Business 3 = Economy */
export enum SeatClass {
    Unknown = 0,
    FirstClass = 1,
    Business = 2,
    Economy = 3,
}

export class SeatDto implements ISeatDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    seatNo!: string | undefined;
    class!: SeatClass;
    type!: SeatType;
    flightId!: number | undefined;
    flightName!: string | undefined;

    constructor(data?: ISeatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.seatNo = _data["seatNo"];
            this.class = _data["class"];
            this.type = _data["type"];
            this.flightId = _data["flightId"];
            this.flightName = _data["flightName"];
        }
    }

    static fromJS(data: any): SeatDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["seatNo"] = this.seatNo;
        data["class"] = this.class;
        data["type"] = this.type;
        data["flightId"] = this.flightId;
        data["flightName"] = this.flightName;
        return data;
    }

    clone(): SeatDto {
        const json = this.toJSON();
        let result = new SeatDto();
        result.init(json);
        return result;
    }
}

export interface ISeatDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    seatNo: string | undefined;
    class: SeatClass;
    type: SeatType;
    flightId: number | undefined;
    flightName: string | undefined;
}

export class SeatDtoPagedResultDto implements ISeatDtoPagedResultDto {
    items!: SeatDto[] | undefined;
    totalCount!: number;

    constructor(data?: ISeatDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SeatDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SeatDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SeatDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SeatDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SeatDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISeatDtoPagedResultDto {
    items: SeatDto[] | undefined;
    totalCount: number;
}

/** 0 = Unknown 1 = Window 2 = Middle 3 = Aisle */
export enum SeatType {
    Unknown = 0,
    Window = 1,
    Middle = 2,
    Aisle = 3,
}

export class UpdateAircraftResult implements IUpdateAircraftResult {
    aircraft!: AircraftDto;

    constructor(data?: IUpdateAircraftResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.aircraft = _data["aircraft"] ? AircraftDto.fromJS(_data["aircraft"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAircraftResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAircraftResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["aircraft"] = this.aircraft ? this.aircraft.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateAircraftResult {
        const json = this.toJSON();
        let result = new UpdateAircraftResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateAircraftResult {
    aircraft: AircraftDto;
}

export class UpdateAirportResult implements IUpdateAirportResult {
    airport!: AirportDto;

    constructor(data?: IUpdateAirportResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airport = _data["airport"] ? AirportDto.fromJS(_data["airport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAirportResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAirportResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airport"] = this.airport ? this.airport.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateAirportResult {
        const json = this.toJSON();
        let result = new UpdateAirportResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateAirportResult {
    airport: AirportDto;
}

export class UpdateFlightResult implements IUpdateFlightResult {
    flight!: FlightDto;

    constructor(data?: IUpdateFlightResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flight = _data["flight"] ? FlightDto.fromJS(_data["flight"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateFlightResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFlightResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flight"] = this.flight ? this.flight.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateFlightResult {
        const json = this.toJSON();
        let result = new UpdateFlightResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateFlightResult {
    flight: FlightDto;
}

export class UpdateSeatRequest implements IUpdateSeatRequest {
    id!: number;
    seatNo!: string | undefined;
    class!: SeatClass;
    type!: SeatType;
    flightId!: number | undefined;

    constructor(data?: IUpdateSeatRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seatNo = _data["seatNo"];
            this.class = _data["class"];
            this.type = _data["type"];
            this.flightId = _data["flightId"];
        }
    }

    static fromJS(data: any): UpdateSeatRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSeatRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seatNo"] = this.seatNo;
        data["class"] = this.class;
        data["type"] = this.type;
        data["flightId"] = this.flightId;
        return data;
    }

    clone(): UpdateSeatRequest {
        const json = this.toJSON();
        let result = new UpdateSeatRequest();
        result.init(json);
        return result;
    }
}

export interface IUpdateSeatRequest {
    id: number;
    seatNo: string | undefined;
    class: SeatClass;
    type: SeatType;
    flightId: number | undefined;
}

export class UpdateSeatResponse implements IUpdateSeatResponse {
    seat!: SeatDto;

    constructor(data?: IUpdateSeatResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seat = _data["seat"] ? SeatDto.fromJS(_data["seat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateSeatResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSeatResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seat"] = this.seat ? this.seat.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateSeatResponse {
        const json = this.toJSON();
        let result = new UpdateSeatResponse();
        result.init(json);
        return result;
    }
}

export interface IUpdateSeatResponse {
    seat: SeatDto;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}