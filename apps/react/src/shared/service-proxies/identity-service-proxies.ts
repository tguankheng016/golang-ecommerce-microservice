//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class IdentitiesServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "http://localhost:8000/api/v2";

    }

    /**
     * Authenticate
     * @return OK
     */
    authenticate(body: HumaAuthenticateRequestBody, signal?: AbortSignal): Promise<HumaAuthenticateResultBody> {
        let url_ = this.baseUrl + "/identities/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<HumaAuthenticateResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HumaAuthenticateResultBody.fromJS(resultData200);
            return Promise.resolve<HumaAuthenticateResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get Current Session
     * @return OK
     */
    getCurrentSession(signal?: AbortSignal): Promise<GetHumaCurrentSessionResultBody> {
        let url_ = this.baseUrl + "/identities/current-session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentSession(_response);
        });
    }

    protected processGetCurrentSession(response: AxiosResponse): Promise<GetHumaCurrentSessionResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetHumaCurrentSessionResultBody.fromJS(resultData200);
            return Promise.resolve<GetHumaCurrentSessionResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get All Permissions
     * @return OK
     */
    getAllPermissions(signal?: AbortSignal): Promise<GetAllPermissionsResultBody> {
        let url_ = this.baseUrl + "/identities/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: AxiosResponse): Promise<GetAllPermissionsResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllPermissionsResultBody.fromJS(resultData200);
            return Promise.resolve<GetAllPermissionsResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * RefreshToken
     * @return OK
     */
    refreshToken(body: HumaRefreshTokenRequestBody, signal?: AbortSignal): Promise<HumaRefreshTokenResultBody> {
        let url_ = this.baseUrl + "/identities/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<HumaRefreshTokenResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HumaRefreshTokenResultBody.fromJS(resultData200);
            return Promise.resolve<HumaRefreshTokenResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * SignOut
     * @return OK
     */
    signOut(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/identities/sign-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }
}

export class RolesServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "http://localhost:8000/api/v2";

    }

    /**
     * Create Role
     * @return OK
     */
    createRole(body: HumaCreateRoleRequestBody, signal?: AbortSignal): Promise<HumaCreateRoleResultBody> {
        let url_ = this.baseUrl + "/identities/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: AxiosResponse): Promise<HumaCreateRoleResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HumaCreateRoleResultBody.fromJS(resultData200);
            return Promise.resolve<HumaCreateRoleResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Update Role
     * @return OK
     */
    updateRole(body: HumaUpdateRoleRequestBody, signal?: AbortSignal): Promise<HumaUpdateRoleResultBody> {
        let url_ = this.baseUrl + "/identities/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: AxiosResponse): Promise<HumaUpdateRoleResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HumaUpdateRoleResultBody.fromJS(resultData200);
            return Promise.resolve<HumaUpdateRoleResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete Role
     * @return OK
     */
    deleteRole(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/identities/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get Role By Id
     * @return OK
     */
    getRoleById(id: number, signal?: AbortSignal): Promise<GetRoleByIdResultBody> {
        let url_ = this.baseUrl + "/identities/role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleById(_response);
        });
    }

    protected processGetRoleById(response: AxiosResponse): Promise<GetRoleByIdResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRoleByIdResultBody.fromJS(resultData200);
            return Promise.resolve<GetRoleByIdResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get Roles
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param filters (optional) 
     * @return OK
     */
    getRoles(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, filters: string | undefined, signal?: AbortSignal): Promise<GetRolesResultBody> {
        let url_ = this.baseUrl + "/identities/roles?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "filters=" + encodeURIComponent("" + filters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<GetRolesResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRolesResultBody.fromJS(resultData200);
            return Promise.resolve<GetRolesResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }
}

export class UsersServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "http://localhost:8000/api/v2";

    }

    /**
     * Create User
     * @return OK
     */
    createUser(body: HumaCreateUserRequestBody, signal?: AbortSignal): Promise<HumaCreateUserResultBody> {
        let url_ = this.baseUrl + "/identities/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: AxiosResponse): Promise<HumaCreateUserResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HumaCreateUserResultBody.fromJS(resultData200);
            return Promise.resolve<HumaCreateUserResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Update User
     * @return OK
     */
    updateUser(body: HumaUpdateUserRequestBody, signal?: AbortSignal): Promise<HumaUpdateUserResultBody> {
        let url_ = this.baseUrl + "/identities/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<HumaUpdateUserResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HumaUpdateUserResultBody.fromJS(resultData200);
            return Promise.resolve<HumaUpdateUserResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Delete User
     * @return OK
     */
    deleteUser(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/identities/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get User By Id
     * @return OK
     */
    getUserById(id: number, signal?: AbortSignal): Promise<GetUserByIdResultBody> {
        let url_ = this.baseUrl + "/identities/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: AxiosResponse): Promise<GetUserByIdResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUserByIdResultBody.fromJS(resultData200);
            return Promise.resolve<GetUserByIdResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get User Permissions
     * @return OK
     */
    getUserPermissions(id: number, signal?: AbortSignal): Promise<GetUserPermissionsResultBody> {
        let url_ = this.baseUrl + "/identities/user/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: AxiosResponse): Promise<GetUserPermissionsResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUserPermissionsResultBody.fromJS(resultData200);
            return Promise.resolve<GetUserPermissionsResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Update User Permissions
     * @return OK
     */
    updateUserPermissions(id: number, body: UpdateUserPermissionsRequestBody, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/identities/user/{id}/permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserPermissions(_response);
        });
    }

    protected processUpdateUserPermissions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Reset User Permissions
     * @return OK
     */
    resetUserPermissions(id: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/identities/user/{id}/reset-permissions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetUserPermissions(_response);
        });
    }

    protected processResetUserPermissions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }

    /**
     * Get Users
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param filters (optional) 
     * @return OK
     */
    getUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, filters: string | undefined, signal?: AbortSignal): Promise<GetUsersResultBody> {
        let url_ = this.baseUrl + "/identities/users?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "filters=" + encodeURIComponent("" + filters) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<GetUsersResultBody> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUsersResultBody.fromJS(resultData200);
            return Promise.resolve<GetUsersResultBody>(result200);

        } else {
            const _responseText = response.data;
            let resultdefault: any = null;
            let resultDatadefault  = _responseText;
            resultdefault = ErrorModel.fromJS(resultDatadefault);
            return throwException("Error", status, _responseText, _headers, resultdefault);

        }
    }
}

export class CreateOrEditRoleDto implements ICreateOrEditRoleDto {
    grantedPermissions!: string[] | undefined;
    id!: number | undefined;
    isDefault!: boolean;
    name!: string;

    constructor(data?: ICreateOrEditRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateOrEditRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }

    clone(): CreateOrEditRoleDto {
        const json = this.toJSON();
        let result = new CreateOrEditRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditRoleDto {
    grantedPermissions: string[] | undefined;
    id: number | undefined;
    isDefault: boolean;
    name: string;
}

export class CreateOrEditUserDto implements ICreateOrEditUserDto {
    email!: string;
    firstName!: string;
    id!: number | undefined;
    lastName!: string;
    password!: string;
    roleIds!: number[] | undefined;
    userName!: string;

    constructor(data?: ICreateOrEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateOrEditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["userName"] = this.userName;
        return data;
    }

    clone(): CreateOrEditUserDto {
        const json = this.toJSON();
        let result = new CreateOrEditUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUserDto {
    email: string;
    firstName: string;
    id: number | undefined;
    lastName: string;
    password: string;
    roleIds: number[] | undefined;
    userName: string;
}

export class ErrorDetail implements IErrorDetail {
    /** Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id' */
    location!: string;
    /** Error message text */
    message!: string;
    /** The value at the given location */
    value!: any;

    constructor(data?: IErrorDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.message = _data["message"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ErrorDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["message"] = this.message;
        data["value"] = this.value;
        return data;
    }

    clone(): ErrorDetail {
        const json = this.toJSON();
        let result = new ErrorDetail();
        result.init(json);
        return result;
    }
}

export interface IErrorDetail {
    /** Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id' */
    location: string;
    /** Error message text */
    message: string;
    /** The value at the given location */
    value: any;
}

export class ErrorModel implements IErrorModel {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail!: string;
    /** Optional list of individual error details */
    errors!: ErrorDetail[] | undefined;
    /** A URI reference that identifies the specific occurrence of the problem. */
    instance!: string;
    /** HTTP status code */
    status!: number;
    /** A short, human-readable summary of the problem type. This value should not change between occurrences of the error. */
    title!: string;
    /** A URI reference to human-readable documentation for the error. */
    type!: string;

    constructor(data?: IErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.type = "about:blank";
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.detail = _data["detail"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(ErrorDetail.fromJS(item));
            }
            this.instance = _data["instance"];
            this.status = _data["status"];
            this.title = _data["title"];
            this.type = _data["type"] !== undefined ? _data["type"] : "about:blank";
        }
    }

    static fromJS(data: any): ErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["detail"] = this.detail;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["instance"] = this.instance;
        data["status"] = this.status;
        data["title"] = this.title;
        data["type"] = this.type;
        return data;
    }

    clone(): ErrorModel {
        const json = this.toJSON();
        let result = new ErrorModel();
        result.init(json);
        return result;
    }
}

export interface IErrorModel {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail: string;
    /** Optional list of individual error details */
    errors: ErrorDetail[] | undefined;
    /** A URI reference that identifies the specific occurrence of the problem. */
    instance: string;
    /** HTTP status code */
    status: number;
    /** A short, human-readable summary of the problem type. This value should not change between occurrences of the error. */
    title: string;
    /** A URI reference to human-readable documentation for the error. */
    type: string;
}

export class GetAllPermissionsResultBody implements IGetAllPermissionsResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    items!: PermissionGroupDto[] | undefined;

    constructor(data?: IGetAllPermissionsResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPermissionsResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionsResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllPermissionsResultBody {
        const json = this.toJSON();
        let result = new GetAllPermissionsResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetAllPermissionsResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    items: PermissionGroupDto[] | undefined;
}

export class GetHumaCurrentSessionResultBody implements IGetHumaCurrentSessionResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    allPermissions!: { [key: string]: boolean; };
    grantedPermissions!: { [key: string]: boolean; };
    user!: UserLoginInfoDto;

    constructor(data?: IGetHumaCurrentSessionResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.allPermissions = {};
            this.grantedPermissions = {};
            this.user = new UserLoginInfoDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (_data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in _data["allPermissions"]) {
                    if (_data["allPermissions"].hasOwnProperty(key))
                        (<any>this.allPermissions)![key] = _data["allPermissions"][key];
                }
            }
            if (_data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in _data["grantedPermissions"]) {
                    if (_data["grantedPermissions"].hasOwnProperty(key))
                        (<any>this.grantedPermissions)![key] = _data["grantedPermissions"][key];
                }
            }
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : new UserLoginInfoDto();
        }
    }

    static fromJS(data: any): GetHumaCurrentSessionResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetHumaCurrentSessionResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    (<any>data["allPermissions"])[key] = (<any>this.allPermissions)[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    (<any>data["grantedPermissions"])[key] = (<any>this.grantedPermissions)[key];
            }
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetHumaCurrentSessionResultBody {
        const json = this.toJSON();
        let result = new GetHumaCurrentSessionResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetHumaCurrentSessionResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    allPermissions: { [key: string]: boolean; };
    grantedPermissions: { [key: string]: boolean; };
    user: UserLoginInfoDto;
}

export class GetRoleByIdResultBody implements IGetRoleByIdResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    role!: CreateOrEditRoleDto;

    constructor(data?: IGetRoleByIdResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new CreateOrEditRoleDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.role = _data["Role"] ? CreateOrEditRoleDto.fromJS(_data["Role"]) : new CreateOrEditRoleDto();
        }
    }

    static fromJS(data: any): GetRoleByIdResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleByIdResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetRoleByIdResultBody {
        const json = this.toJSON();
        let result = new GetRoleByIdResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetRoleByIdResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    role: CreateOrEditRoleDto;
}

export class GetRolesResultBody implements IGetRolesResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    items!: RoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetRolesResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetRolesResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetRolesResultBody {
        const json = this.toJSON();
        let result = new GetRolesResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetRolesResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class GetUserByIdResultBody implements IGetUserByIdResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    user!: CreateOrEditUserDto;

    constructor(data?: IGetUserByIdResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new CreateOrEditUserDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.user = _data["User"] ? CreateOrEditUserDto.fromJS(_data["User"]) : new CreateOrEditUserDto();
        }
    }

    static fromJS(data: any): GetUserByIdResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetUserByIdResultBody {
        const json = this.toJSON();
        let result = new GetUserByIdResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetUserByIdResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    user: CreateOrEditUserDto;
}

export class GetUserPermissionsResultBody implements IGetUserPermissionsResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    items!: string[] | undefined;

    constructor(data?: IGetUserPermissionsResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item);
        }
        return data;
    }

    clone(): GetUserPermissionsResultBody {
        const json = this.toJSON();
        let result = new GetUserPermissionsResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    items: string[] | undefined;
}

export class GetUsersResultBody implements IGetUsersResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    items!: UserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetUsersResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetUsersResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetUsersResultBody {
        const json = this.toJSON();
        let result = new GetUsersResultBody();
        result.init(json);
        return result;
    }
}

export interface IGetUsersResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    items: UserDto[] | undefined;
    totalCount: number;
}

export class HumaAuthenticateRequestBody implements IHumaAuthenticateRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    password!: string;
    usernameOrEmailAddress!: string;

    constructor(data?: IHumaAuthenticateRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.password = _data["password"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
        }
    }

    static fromJS(data: any): HumaAuthenticateRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaAuthenticateRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["password"] = this.password;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        return data;
    }

    clone(): HumaAuthenticateRequestBody {
        const json = this.toJSON();
        let result = new HumaAuthenticateRequestBody();
        result.init(json);
        return result;
    }
}

export interface IHumaAuthenticateRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    password: string;
    usernameOrEmailAddress: string;
}

export class HumaAuthenticateResultBody implements IHumaAuthenticateResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    accessToken!: string;
    expireInSeconds!: number;
    refreshToken!: string;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IHumaAuthenticateResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): HumaAuthenticateResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaAuthenticateResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }

    clone(): HumaAuthenticateResultBody {
        const json = this.toJSON();
        let result = new HumaAuthenticateResultBody();
        result.init(json);
        return result;
    }
}

export interface IHumaAuthenticateResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    accessToken: string;
    expireInSeconds: number;
    refreshToken: string;
    refreshTokenExpireInSeconds: number;
}

export class HumaCreateRoleRequestBody implements IHumaCreateRoleRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    grantedPermissions!: string[] | undefined;
    id!: number | undefined;
    isDefault!: boolean;
    name!: string;

    constructor(data?: IHumaCreateRoleRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): HumaCreateRoleRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaCreateRoleRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }

    clone(): HumaCreateRoleRequestBody {
        const json = this.toJSON();
        let result = new HumaCreateRoleRequestBody();
        result.init(json);
        return result;
    }
}

export interface IHumaCreateRoleRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    grantedPermissions: string[] | undefined;
    id: number | undefined;
    isDefault: boolean;
    name: string;
}

export class HumaCreateRoleResultBody implements IHumaCreateRoleResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    role!: RoleDto;

    constructor(data?: IHumaCreateRoleResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.role = _data["Role"] ? RoleDto.fromJS(_data["Role"]) : new RoleDto();
        }
    }

    static fromJS(data: any): HumaCreateRoleResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaCreateRoleResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): HumaCreateRoleResultBody {
        const json = this.toJSON();
        let result = new HumaCreateRoleResultBody();
        result.init(json);
        return result;
    }
}

export interface IHumaCreateRoleResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    role: RoleDto;
}

export class HumaCreateUserRequestBody implements IHumaCreateUserRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    email!: string;
    firstName!: string;
    id!: number | undefined;
    lastName!: string;
    password!: string;
    roleIds!: number[] | undefined;
    userName!: string;

    constructor(data?: IHumaCreateUserRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): HumaCreateUserRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaCreateUserRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["userName"] = this.userName;
        return data;
    }

    clone(): HumaCreateUserRequestBody {
        const json = this.toJSON();
        let result = new HumaCreateUserRequestBody();
        result.init(json);
        return result;
    }
}

export interface IHumaCreateUserRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    email: string;
    firstName: string;
    id: number | undefined;
    lastName: string;
    password: string;
    roleIds: number[] | undefined;
    userName: string;
}

export class HumaCreateUserResultBody implements IHumaCreateUserResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    user!: UserDto;

    constructor(data?: IHumaCreateUserResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.user = _data["User"] ? UserDto.fromJS(_data["User"]) : new UserDto();
        }
    }

    static fromJS(data: any): HumaCreateUserResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaCreateUserResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): HumaCreateUserResultBody {
        const json = this.toJSON();
        let result = new HumaCreateUserResultBody();
        result.init(json);
        return result;
    }
}

export interface IHumaCreateUserResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    user: UserDto;
}

export class HumaRefreshTokenRequestBody implements IHumaRefreshTokenRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    token!: string;

    constructor(data?: IHumaRefreshTokenRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): HumaRefreshTokenRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaRefreshTokenRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["token"] = this.token;
        return data;
    }

    clone(): HumaRefreshTokenRequestBody {
        const json = this.toJSON();
        let result = new HumaRefreshTokenRequestBody();
        result.init(json);
        return result;
    }
}

export interface IHumaRefreshTokenRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    token: string;
}

export class HumaRefreshTokenResultBody implements IHumaRefreshTokenResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    accessToken!: string;
    expireInSeconds!: number;

    constructor(data?: IHumaRefreshTokenResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): HumaRefreshTokenResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaRefreshTokenResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }

    clone(): HumaRefreshTokenResultBody {
        const json = this.toJSON();
        let result = new HumaRefreshTokenResultBody();
        result.init(json);
        return result;
    }
}

export interface IHumaRefreshTokenResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    accessToken: string;
    expireInSeconds: number;
}

export class HumaUpdateRoleRequestBody implements IHumaUpdateRoleRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    grantedPermissions!: string[] | undefined;
    id!: number | undefined;
    isDefault!: boolean;
    name!: string;

    constructor(data?: IHumaUpdateRoleRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): HumaUpdateRoleRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaUpdateRoleRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }

    clone(): HumaUpdateRoleRequestBody {
        const json = this.toJSON();
        let result = new HumaUpdateRoleRequestBody();
        result.init(json);
        return result;
    }
}

export interface IHumaUpdateRoleRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    grantedPermissions: string[] | undefined;
    id: number | undefined;
    isDefault: boolean;
    name: string;
}

export class HumaUpdateRoleResultBody implements IHumaUpdateRoleResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    role!: RoleDto;

    constructor(data?: IHumaUpdateRoleResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.role = _data["Role"] ? RoleDto.fromJS(_data["Role"]) : new RoleDto();
        }
    }

    static fromJS(data: any): HumaUpdateRoleResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaUpdateRoleResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["Role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): HumaUpdateRoleResultBody {
        const json = this.toJSON();
        let result = new HumaUpdateRoleResultBody();
        result.init(json);
        return result;
    }
}

export interface IHumaUpdateRoleResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    role: RoleDto;
}

export class HumaUpdateUserRequestBody implements IHumaUpdateUserRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    email!: string;
    firstName!: string;
    id!: number | undefined;
    lastName!: string;
    password!: string;
    roleIds!: number[] | undefined;
    userName!: string;

    constructor(data?: IHumaUpdateUserRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): HumaUpdateUserRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaUpdateUserRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["userName"] = this.userName;
        return data;
    }

    clone(): HumaUpdateUserRequestBody {
        const json = this.toJSON();
        let result = new HumaUpdateUserRequestBody();
        result.init(json);
        return result;
    }
}

export interface IHumaUpdateUserRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    email: string;
    firstName: string;
    id: number | undefined;
    lastName: string;
    password: string;
    roleIds: number[] | undefined;
    userName: string;
}

export class HumaUpdateUserResultBody implements IHumaUpdateUserResultBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    user!: UserDto;

    constructor(data?: IHumaUpdateUserResultBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            this.user = _data["User"] ? UserDto.fromJS(_data["User"]) : new UserDto();
        }
    }

    static fromJS(data: any): HumaUpdateUserResultBody {
        data = typeof data === 'object' ? data : {};
        let result = new HumaUpdateUserResultBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): HumaUpdateUserResultBody {
        const json = this.toJSON();
        let result = new HumaUpdateUserResultBody();
        result.init(json);
        return result;
    }
}

export interface IHumaUpdateUserResultBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    user: UserDto;
}

export class NullInt64 implements INullInt64 {
    int64!: number;
    valid!: boolean;

    constructor(data?: INullInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.int64 = _data["Int64"];
            this.valid = _data["Valid"];
        }
    }

    static fromJS(data: any): NullInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new NullInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Int64"] = this.int64;
        data["Valid"] = this.valid;
        return data;
    }

    clone(): NullInt64 {
        const json = this.toJSON();
        let result = new NullInt64();
        result.init(json);
        return result;
    }
}

export interface INullInt64 {
    int64: number;
    valid: boolean;
}

export class NullTime implements INullTime {
    time!: moment.Moment;
    valid!: boolean;

    constructor(data?: INullTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["Time"] ? moment(_data["Time"].toString()) : <any>undefined;
            this.valid = _data["Valid"];
        }
    }

    static fromJS(data: any): NullTime {
        data = typeof data === 'object' ? data : {};
        let result = new NullTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["Valid"] = this.valid;
        return data;
    }

    clone(): NullTime {
        const json = this.toJSON();
        let result = new NullTime();
        result.init(json);
        return result;
    }
}

export interface INullTime {
    time: moment.Moment;
    valid: boolean;
}

export class PermissionDto implements IPermissionDto {
    displayName!: string;
    isGranted!: boolean;
    name!: string;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.isGranted = _data["isGranted"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isGranted"] = this.isGranted;
        data["name"] = this.name;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    displayName: string;
    isGranted: boolean;
    name: string;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    groupName!: string;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionGroupDto {
        const json = this.toJSON();
        let result = new PermissionGroupDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionGroupDto {
    groupName: string;
    permissions: PermissionDto[] | undefined;
}

export class RoleDto implements IRoleDto {
    createdAt!: moment.Moment;
    createdBy!: NullInt64;
    id!: number;
    isDefault!: boolean;
    isStatic!: string;
    name!: string;
    updatedAt!: NullTime;
    updatedBy!: NullInt64;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new NullInt64();
            this.updatedAt = new NullTime();
            this.updatedBy = new NullInt64();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? NullInt64.fromJS(_data["createdBy"]) : new NullInt64();
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.name = _data["name"];
            this.updatedAt = _data["updatedAt"] ? NullTime.fromJS(_data["updatedAt"]) : new NullTime();
            this.updatedBy = _data["updatedBy"] ? NullInt64.fromJS(_data["updatedBy"]) : new NullInt64();
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["name"] = this.name;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toJSON() : <any>undefined;
        data["updatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    createdAt: moment.Moment;
    createdBy: NullInt64;
    id: number;
    isDefault: boolean;
    isStatic: string;
    name: string;
    updatedAt: NullTime;
    updatedBy: NullInt64;
}

export class UpdateUserPermissionsRequestBody implements IUpdateUserPermissionsRequestBody {
    /** A URL to the JSON Schema for this object. */
    readonly $schema!: string;
    grantedPermissions!: string[] | undefined;

    constructor(data?: IUpdateUserPermissionsRequestBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).$schema = _data["$schema"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsRequestBody {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsRequestBody();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["$schema"] = this.$schema;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): UpdateUserPermissionsRequestBody {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsRequestBody();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsRequestBody {
    /** A URL to the JSON Schema for this object. */
    $schema: string;
    grantedPermissions: string[] | undefined;
}

export class UserDto implements IUserDto {
    createdAt!: moment.Moment;
    createdBy!: NullInt64;
    email!: string;
    firstName!: string;
    id!: number;
    lastName!: string;
    updatedAt!: NullTime;
    updatedBy!: NullInt64;
    userName!: string;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new NullInt64();
            this.updatedAt = new NullTime();
            this.updatedBy = new NullInt64();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? moment(_data["createdAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? NullInt64.fromJS(_data["createdBy"]) : new NullInt64();
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.updatedAt = _data["updatedAt"] ? NullTime.fromJS(_data["updatedAt"]) : new NullTime();
            this.updatedBy = _data["updatedBy"] ? NullInt64.fromJS(_data["updatedBy"]) : new NullInt64();
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toJSON() : <any>undefined;
        data["updatedBy"] = this.updatedBy ? this.updatedBy.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    createdAt: moment.Moment;
    createdBy: NullInt64;
    email: string;
    firstName: string;
    id: number;
    lastName: string;
    updatedAt: NullTime;
    updatedBy: NullInt64;
    userName: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    email!: string;
    firstName!: string;
    id!: number;
    lastName!: string;
    userName!: string;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    email: string;
    firstName: string;
    id: number;
    lastName: string;
    userName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}