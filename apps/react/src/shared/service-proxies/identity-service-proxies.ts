//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class IdentitiesServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Get All App Permissions
     * @return OK
     */
    getAllAppPermissions(signal?: AbortSignal): Promise<GetAllPermissionResult> {
        let url_ = this.baseUrl + "/api/v1/identities/app-permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAppPermissions(_response);
        });
    }

    protected processGetAllAppPermissions(response: AxiosResponse): Promise<GetAllPermissionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllPermissionResult.fromJS(resultData200);
            return Promise.resolve<GetAllPermissionResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllPermissionResult>(null as any);
    }

    /**
     * Authenticate
     * @param authenticateRequest AuthenticateRequest
     * @return OK
     */
    authenticate(authenticateRequest: AuthenticateRequest, signal?: AbortSignal): Promise<AuthenticateResult> {
        let url_ = this.baseUrl + "/api/v1/identities/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(authenticateRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthenticateResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResult.fromJS(resultData200);
            return Promise.resolve<AuthenticateResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResult>(null as any);
    }

    /**
     * Get Current User Session
     * @return OK
     */
    getCurrentSession(signal?: AbortSignal): Promise<GetCurrentSessionResult> {
        let url_ = this.baseUrl + "/api/v1/identities/current-session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentSession(_response);
        });
    }

    protected processGetCurrentSession(response: AxiosResponse): Promise<GetCurrentSessionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCurrentSessionResult.fromJS(resultData200);
            return Promise.resolve<GetCurrentSessionResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCurrentSessionResult>(null as any);
    }

    /**
     * OAuthAuthenticate
     * @param oAuthAuthenticateRequest OAuthAuthenticateRequest
     * @return OK
     */
    oAuthAuthenticate(oAuthAuthenticateRequest: OAuthAuthenticateRequest, signal?: AbortSignal): Promise<AuthenticateResult> {
        let url_ = this.baseUrl + "/api/v1/identities/oauth-authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(oAuthAuthenticateRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOAuthAuthenticate(_response);
        });
    }

    protected processOAuthAuthenticate(response: AxiosResponse): Promise<AuthenticateResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResult.fromJS(resultData200);
            return Promise.resolve<AuthenticateResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResult>(null as any);
    }

    /**
     * Refresh access token
     * @param refreshTokenRequest RefreshTokenRequest
     * @return OK
     */
    refreshToken(refreshTokenRequest: RefreshTokenRequest, signal?: AbortSignal): Promise<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/v1/identities/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshTokenRequest);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<RefreshTokenResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefreshTokenResult.fromJS(resultData200);
            return Promise.resolve<RefreshTokenResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefreshTokenResult>(null as any);
    }

    /**
     * Sign out
     * @return OK
     */
    signOut(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identities/sign-out";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSignOut(_response);
        });
    }

    protected processSignOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class RolesServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update role
     * @param editRoleDto (optional) EditRoleDto
     * @return OK
     */
    updateRole(editRoleDto: EditRoleDto | null | undefined, signal?: AbortSignal): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/v1/identities/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(editRoleDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * Create new role
     * @param createRoleDto (optional) CreateRoleDto
     * @return OK
     */
    createRole(createRoleDto: CreateRoleDto | null | undefined, signal?: AbortSignal): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/v1/identities/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createRoleDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * Get role by id
     * @param roleId Role Id
     * @return OK
     */
    getRoleById(roleId: number, signal?: AbortSignal): Promise<GetRoleByIdResult> {
        let url_ = this.baseUrl + "/api/v1/identities/role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleById(_response);
        });
    }

    protected processGetRoleById(response: AxiosResponse): Promise<GetRoleByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRoleByIdResult.fromJS(resultData200);
            return Promise.resolve<GetRoleByIdResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRoleByIdResult>(null as any);
    }

    /**
     * Delete role
     * @param roleId Role Id
     * @return OK
     */
    deleteRole(roleId: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identities/role/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all roles
     * @param filters (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getAllRoles(filters: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, signal?: AbortSignal): Promise<GetRolesResult> {
        let url_ = this.baseUrl + "/api/v1/identities/roles?";
        if (filters !== undefined && filters !== null)
            url_ += "filters=" + encodeURIComponent("" + filters) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllRoles(_response);
        });
    }

    protected processGetAllRoles(response: AxiosResponse): Promise<GetRolesResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRolesResult.fromJS(resultData200);
            return Promise.resolve<GetRolesResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRolesResult>(null as any);
    }
}

export class UsersServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update user
     * @param editUserDto (optional) EditUserDto
     * @return OK
     */
    updateUser(editUserDto: EditUserDto | null | undefined, signal?: AbortSignal): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/v1/identities/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(editUserDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * Create new user
     * @param createUserDto (optional) CreateUserDto
     * @return OK
     */
    createUser(createUserDto: CreateUserDto | null | undefined, signal?: AbortSignal): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/v1/identities/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createUserDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * Get user by id
     * @param userId User Id
     * @return OK
     */
    getUserById(userId: number, signal?: AbortSignal): Promise<GetUserByIdResult> {
        let url_ = this.baseUrl + "/api/v1/identities/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: AxiosResponse): Promise<GetUserByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUserByIdResult.fromJS(resultData200);
            return Promise.resolve<GetUserByIdResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUserByIdResult>(null as any);
    }

    /**
     * Delete user
     * @param userId User Id
     * @return OK
     */
    deleteUser(userId: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identities/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get user permissions
     * @param userId User Id
     * @return OK
     */
    getUserPermissions(userId: number, signal?: AbortSignal): Promise<UserPermissionsResult> {
        let url_ = this.baseUrl + "/api/v1/identities/user/{userId}/permissions";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: AxiosResponse): Promise<UserPermissionsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserPermissionsResult.fromJS(resultData200);
            return Promise.resolve<UserPermissionsResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserPermissionsResult>(null as any);
    }

    /**
     * Update user permissions
     * @param userId User Id
     * @param updateUserPermissionDto (optional) UpdateUserPermissionDto
     * @return OK
     */
    updateUserPermissions(userId: number, updateUserPermissionDto: UpdateUserPermissionDto | null | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identities/user/{userId}/permissions";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateUserPermissionDto);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserPermissions(_response);
        });
    }

    protected processUpdateUserPermissions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Reset user permissions
     * @param userId User Id
     * @return OK
     */
    resetUserPermissions(userId: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identities/user/{userId}/reset-permissions";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetUserPermissions(_response);
        });
    }

    protected processResetUserPermissions(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Get all users
     * @param filters (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getAllUsers(filters: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, signal?: AbortSignal): Promise<GetUsersResult> {
        let url_ = this.baseUrl + "/api/v1/identities/users?";
        if (filters !== undefined && filters !== null)
            url_ += "filters=" + encodeURIComponent("" + filters) + "&";
        if (maxResultCount !== undefined && maxResultCount !== null)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount !== undefined && skipCount !== null)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting !== undefined && sorting !== null)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: AxiosResponse): Promise<GetUsersResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUsersResult.fromJS(resultData200);
            return Promise.resolve<GetUsersResult>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUsersResult>(null as any);
    }
}

export class AuthenticateRequest implements IAuthenticateRequest {
    password!: string;
    usernameOrEmailAddress!: string;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        return data;
    }

    clone(): AuthenticateRequest {
        const json = this.toJSON();
        let result = new AuthenticateRequest();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateRequest {
    password: string;
    usernameOrEmailAddress: string;
}

export class AuthenticateResult implements IAuthenticateResult {
    access_token!: string | undefined;
    expire_in_seconds!: number | undefined;
    refresh_token!: string | undefined;
    refresh_token_expire_in_seconds!: number | undefined;

    constructor(data?: IAuthenticateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.access_token = _data["access_token"];
            this.expire_in_seconds = _data["expire_in_seconds"];
            this.refresh_token = _data["refresh_token"];
            this.refresh_token_expire_in_seconds = _data["refresh_token_expire_in_seconds"];
        }
    }

    static fromJS(data: any): AuthenticateResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["expire_in_seconds"] = this.expire_in_seconds;
        data["refresh_token"] = this.refresh_token;
        data["refresh_token_expire_in_seconds"] = this.refresh_token_expire_in_seconds;
        return data;
    }

    clone(): AuthenticateResult {
        const json = this.toJSON();
        let result = new AuthenticateResult();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResult {
    access_token: string | undefined;
    expire_in_seconds: number | undefined;
    refresh_token: string | undefined;
    refresh_token_expire_in_seconds: number | undefined;
}

export class CreateOrEditRoleDto implements ICreateOrEditRoleDto {
    grantedPermissions!: string[] | undefined;
    id!: number | undefined;
    isDefault!: boolean | undefined;
    name!: string;

    constructor(data?: ICreateOrEditRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateOrEditRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }

    clone(): CreateOrEditRoleDto {
        const json = this.toJSON();
        let result = new CreateOrEditRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditRoleDto {
    grantedPermissions: string[] | undefined;
    id: number | undefined;
    isDefault: boolean | undefined;
    name: string;
}

export class CreateOrEditUserDto implements ICreateOrEditUserDto {
    email!: string;
    firstName!: string;
    id!: number | undefined;
    lastName!: string;
    password!: string | undefined;
    roleIds!: number[] | undefined;
    userName!: string;

    constructor(data?: ICreateOrEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateOrEditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["userName"] = this.userName;
        return data;
    }

    clone(): CreateOrEditUserDto {
        const json = this.toJSON();
        let result = new CreateOrEditUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUserDto {
    email: string;
    firstName: string;
    id: number | undefined;
    lastName: string;
    password: string | undefined;
    roleIds: number[] | undefined;
    userName: string;
}

export class CreateRoleDto implements ICreateRoleDto {
    grantedPermissions!: string[] | undefined;
    id!: number | undefined;
    isDefault!: boolean | undefined;
    name!: string;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    grantedPermissions: string[] | undefined;
    id: number | undefined;
    isDefault: boolean | undefined;
    name: string;
}

export class CreateUserDto implements ICreateUserDto {
    email!: string;
    firstName!: string;
    id!: number | undefined;
    lastName!: string;
    password!: string | undefined;
    roleIds!: number[] | undefined;
    userName!: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["userName"] = this.userName;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    email: string;
    firstName: string;
    id: number | undefined;
    lastName: string;
    password: string | undefined;
    roleIds: number[] | undefined;
    userName: string;
}

export class EditRoleDto implements IEditRoleDto {
    grantedPermissions!: string[] | undefined;
    id!: number | undefined;
    isDefault!: boolean | undefined;
    name!: string;

    constructor(data?: IEditRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["name"] = this.name;
        return data;
    }

    clone(): EditRoleDto {
        const json = this.toJSON();
        let result = new EditRoleDto();
        result.init(json);
        return result;
    }
}

export interface IEditRoleDto {
    grantedPermissions: string[] | undefined;
    id: number | undefined;
    isDefault: boolean | undefined;
    name: string;
}

export class EditUserDto implements IEditUserDto {
    email!: string;
    firstName!: string;
    id!: number | undefined;
    lastName!: string;
    password!: string | undefined;
    roleIds!: number[] | undefined;
    userName!: string;

    constructor(data?: IEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.password = _data["password"];
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): EditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["password"] = this.password;
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["userName"] = this.userName;
        return data;
    }

    clone(): EditUserDto {
        const json = this.toJSON();
        let result = new EditUserDto();
        result.init(json);
        return result;
    }
}

export interface IEditUserDto {
    email: string;
    firstName: string;
    id: number | undefined;
    lastName: string;
    password: string | undefined;
    roleIds: number[] | undefined;
    userName: string;
}

export class GetAllPermissionResult implements IGetAllPermissionResult {
    items!: PermissionGroupDto[] | undefined;

    constructor(data?: IGetAllPermissionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPermissionResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllPermissionResult {
        const json = this.toJSON();
        let result = new GetAllPermissionResult();
        result.init(json);
        return result;
    }
}

export interface IGetAllPermissionResult {
    items: PermissionGroupDto[] | undefined;
}

export class GetCurrentSessionResult implements IGetCurrentSessionResult {
    allPermissions!: { [key: string]: boolean; } | undefined;
    grantedPermissions!: { [key: string]: boolean; } | undefined;
    user!: UserLoginInfoDto | undefined;

    constructor(data?: IGetCurrentSessionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in _data["allPermissions"]) {
                    if (_data["allPermissions"].hasOwnProperty(key))
                        (<any>this.allPermissions)![key] = _data["allPermissions"][key];
                }
            }
            if (_data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in _data["grantedPermissions"]) {
                    if (_data["grantedPermissions"].hasOwnProperty(key))
                        (<any>this.grantedPermissions)![key] = _data["grantedPermissions"][key];
                }
            }
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentSessionResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentSessionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    (<any>data["allPermissions"])[key] = (<any>this.allPermissions)[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    (<any>data["grantedPermissions"])[key] = (<any>this.grantedPermissions)[key];
            }
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCurrentSessionResult {
        const json = this.toJSON();
        let result = new GetCurrentSessionResult();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentSessionResult {
    allPermissions: { [key: string]: boolean; } | undefined;
    grantedPermissions: { [key: string]: boolean; } | undefined;
    user: UserLoginInfoDto | undefined;
}

export class GetRoleByIdResult implements IGetRoleByIdResult {
    role!: CreateOrEditRoleDto | undefined;

    constructor(data?: IGetRoleByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? CreateOrEditRoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRoleByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetRoleByIdResult {
        const json = this.toJSON();
        let result = new GetRoleByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetRoleByIdResult {
    role: CreateOrEditRoleDto | undefined;
}

export class GetRolesResult implements IGetRolesResult {
    items!: RoleDto[] | undefined;
    totalCount!: number | undefined;

    constructor(data?: IGetRolesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetRolesResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetRolesResult {
        const json = this.toJSON();
        let result = new GetRolesResult();
        result.init(json);
        return result;
    }
}

export interface IGetRolesResult {
    items: RoleDto[] | undefined;
    totalCount: number | undefined;
}

export class GetUserByIdResult implements IGetUserByIdResult {
    user!: CreateOrEditUserDto | undefined;

    constructor(data?: IGetUserByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? CreateOrEditUserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetUserByIdResult {
        const json = this.toJSON();
        let result = new GetUserByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserByIdResult {
    user: CreateOrEditUserDto | undefined;
}

export class GetUsersResult implements IGetUsersResult {
    items!: UserDto[] | undefined;
    totalCount!: number | undefined;

    constructor(data?: IGetUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetUsersResult {
        const json = this.toJSON();
        let result = new GetUsersResult();
        result.init(json);
        return result;
    }
}

export interface IGetUsersResult {
    items: UserDto[] | undefined;
    totalCount: number | undefined;
}

export class OAuthAuthenticateRequest implements IOAuthAuthenticateRequest {
    code!: string;
    redirect_uri!: string;

    constructor(data?: IOAuthAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.redirect_uri = _data["redirect_uri"];
        }
    }

    static fromJS(data: any): OAuthAuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["redirect_uri"] = this.redirect_uri;
        return data;
    }

    clone(): OAuthAuthenticateRequest {
        const json = this.toJSON();
        let result = new OAuthAuthenticateRequest();
        result.init(json);
        return result;
    }
}

export interface IOAuthAuthenticateRequest {
    code: string;
    redirect_uri: string;
}

export class PermissionDto implements IPermissionDto {
    displayName!: string | undefined;
    isGranted!: boolean | undefined;
    name!: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.isGranted = _data["isGranted"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["isGranted"] = this.isGranted;
        data["name"] = this.name;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    displayName: string | undefined;
    isGranted: boolean | undefined;
    name: string | undefined;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    groupName!: string | undefined;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionGroupDto {
        const json = this.toJSON();
        let result = new PermissionGroupDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionGroupDto {
    groupName: string | undefined;
    permissions: PermissionDto[] | undefined;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    token!: string;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): RefreshTokenRequest {
        const json = this.toJSON();
        let result = new RefreshTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenRequest {
    token: string;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }

    clone(): RefreshTokenResult {
        const json = this.toJSON();
        let result = new RefreshTokenResult();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class RoleDto implements IRoleDto {
    createdAt!: string | undefined;
    id!: number | undefined;
    isDefault!: boolean | undefined;
    isStatic!: boolean | undefined;
    name!: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"];
            this.id = _data["id"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt;
        data["id"] = this.id;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["name"] = this.name;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    createdAt: string | undefined;
    id: number | undefined;
    isDefault: boolean | undefined;
    isStatic: boolean | undefined;
    name: string | undefined;
}

export class UpdateUserPermissionDto implements IUpdateUserPermissionDto {
    grantedPermissions!: string[] | undefined;

    constructor(data?: IUpdateUserPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): UpdateUserPermissionDto {
        const json = this.toJSON();
        let result = new UpdateUserPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionDto {
    grantedPermissions: string[] | undefined;
}

export class UserDto implements IUserDto {
    email!: string | undefined;
    firstName!: string | undefined;
    id!: number | undefined;
    lastName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    email: string | undefined;
    firstName: string | undefined;
    id: number | undefined;
    lastName: string | undefined;
    userName: string | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    email!: string | undefined;
    firstName!: string | undefined;
    id!: number | undefined;
    lastName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    email: string | undefined;
    firstName: string | undefined;
    id: number | undefined;
    lastName: string | undefined;
    userName: string | undefined;
}

export class UserPermissionsResult implements IUserPermissionsResult {
    items!: string[] | undefined;

    constructor(data?: IUserPermissionsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): UserPermissionsResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }

    clone(): UserPermissionsResult {
        const json = this.toJSON();
        let result = new UserPermissionsResult();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionsResult {
    items: string[] | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}