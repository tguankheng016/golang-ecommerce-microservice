//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import moment from 'moment';

export class IdentityServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Refresh Token
     * @return OK
     */
    refreshToken(body: RefreshTokenRequest, signal?: AbortSignal): Promise<RefreshTokenResponse> {
        let url_ = this.baseUrl + "/api/v1/identity/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRefreshToken(_response);
        });
    }

    protected processRefreshToken(response: AxiosResponse): Promise<RefreshTokenResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RefreshTokenResponse.fromJS(resultData200);
            return Promise.resolve<RefreshTokenResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RefreshTokenResponse>(null as any);
    }

    /**
     * OauthAuthenticate
     * @return OK
     */
    oAuthAuthenticate(body: OAuthAuthenticateRequest, signal?: AbortSignal): Promise<OAuthAuthenticateResponse> {
        let url_ = this.baseUrl + "/api/v1/identity/oauth-authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOAuthAuthenticate(_response);
        });
    }

    protected processOAuthAuthenticate(response: AxiosResponse): Promise<OAuthAuthenticateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OAuthAuthenticateResponse.fromJS(resultData200);
            return Promise.resolve<OAuthAuthenticateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OAuthAuthenticateResponse>(null as any);
    }

    /**
     * Logout
     */
    logout(signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identity/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * GetCurrentSession
     * @return OK
     */
    getCurrentSession(signal?: AbortSignal): Promise<GetCurrentSessionResult> {
        let url_ = this.baseUrl + "/api/v1/identity/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentSession(_response);
        });
    }

    protected processGetCurrentSession(response: AxiosResponse): Promise<GetCurrentSessionResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCurrentSessionResult.fromJS(resultData200);
            return Promise.resolve<GetCurrentSessionResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCurrentSessionResult>(null as any);
    }

    /**
     * Get All Permissions
     * @return OK
     */
    getAllPermissions(signal?: AbortSignal): Promise<GetAllPermissionsResult> {
        let url_ = this.baseUrl + "/api/v1/identity/permissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: AxiosResponse): Promise<GetAllPermissionsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllPermissionsResult.fromJS(resultData200);
            return Promise.resolve<GetAllPermissionsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllPermissionsResult>(null as any);
    }

    /**
     * Authenticate
     * @return OK
     */
    authenticate(body: AuthenticateRequest, signal?: AbortSignal): Promise<AuthenticateResponse> {
        let url_ = this.baseUrl + "/api/v1/identity/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthenticateResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResponse.fromJS(resultData200);
            return Promise.resolve<AuthenticateResponse>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResponse>(null as any);
    }
}

export class RoleServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update New Role
     * @return OK
     */
    updateRole(body: EditRoleDto, signal?: AbortSignal): Promise<UpdateRoleResult> {
        let url_ = this.baseUrl + "/api/v1/identity/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateRole(_response);
        });
    }

    protected processUpdateRole(response: AxiosResponse): Promise<UpdateRoleResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateRoleResult.fromJS(resultData200);
            return Promise.resolve<UpdateRoleResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateRoleResult>(null as any);
    }

    /**
     * Create New Role
     * @return OK
     */
    createRole(body: CreateRoleDto, signal?: AbortSignal): Promise<CreateRoleResult> {
        let url_ = this.baseUrl + "/api/v1/identity/role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateRole(_response);
        });
    }

    protected processCreateRole(response: AxiosResponse): Promise<CreateRoleResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateRoleResult.fromJS(resultData200);
            return Promise.resolve<CreateRoleResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateRoleResult>(null as any);
    }

    /**
     * Get All Roles
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getRoles(skipCount: number, maxResultCount: number, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetRolesResult> {
        let url_ = this.baseUrl + "/api/v1/identity/roles?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<GetRolesResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRolesResult.fromJS(resultData200);
            return Promise.resolve<GetRolesResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRolesResult>(null as any);
    }

    /**
     * Get Role By Id
     * @return OK
     */
    getRoleById(roleid: number, signal?: AbortSignal): Promise<GetRoleByIdResult> {
        let url_ = this.baseUrl + "/api/v1/identity/role/{roleid}";
        if (roleid === undefined || roleid === null)
            throw new Error("The parameter 'roleid' must be defined.");
        url_ = url_.replace("{roleid}", encodeURIComponent("" + roleid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleById(_response);
        });
    }

    protected processGetRoleById(response: AxiosResponse): Promise<GetRoleByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRoleByIdResult.fromJS(resultData200);
            return Promise.resolve<GetRoleByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRoleByIdResult>(null as any);
    }

    /**
     * Delete Role
     */
    deleteRole(roleid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identity/role/{roleid}";
        if (roleid === undefined || roleid === null)
            throw new Error("The parameter 'roleid' must be defined.");
        url_ = url_.replace("{roleid}", encodeURIComponent("" + roleid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteRole(_response);
        });
    }

    protected processDeleteRole(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class UserServiceProxy {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "";

    }

    /**
     * Update User Permissions
     * @return OK
     */
    updateUserPermissions(userid: number, body: string[], signal?: AbortSignal): Promise<UpdateUserPermissionsResult> {
        let url_ = this.baseUrl + "/api/v1/identity/user/{userid}/permissions";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUserPermissions(_response);
        });
    }

    protected processUpdateUserPermissions(response: AxiosResponse): Promise<UpdateUserPermissionsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateUserPermissionsResult.fromJS(resultData200);
            return Promise.resolve<UpdateUserPermissionsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateUserPermissionsResult>(null as any);
    }

    /**
     * Update User
     * @return OK
     */
    updateUser(body: EditUserDto, signal?: AbortSignal): Promise<UpdateUserResult> {
        let url_ = this.baseUrl + "/api/v1/identity/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<UpdateUserResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateUserResult.fromJS(resultData200);
            return Promise.resolve<UpdateUserResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateUserResult>(null as any);
    }

    /**
     * Create New User
     * @return OK
     */
    createUser(body: CreateUserDto, signal?: AbortSignal): Promise<CreateUserResult> {
        let url_ = this.baseUrl + "/api/v1/identity/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: AxiosResponse): Promise<CreateUserResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreateUserResult.fromJS(resultData200);
            return Promise.resolve<CreateUserResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateUserResult>(null as any);
    }

    /**
     * Reset User Permissions
     * @return OK
     */
    resetUserPermissions(userid: number, signal?: AbortSignal): Promise<ResetUserPermissionsResult> {
        let url_ = this.baseUrl + "/api/v1/identity/user/{userid}/reset-permissions";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetUserPermissions(_response);
        });
    }

    protected processResetUserPermissions(response: AxiosResponse): Promise<ResetUserPermissionsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResetUserPermissionsResult.fromJS(resultData200);
            return Promise.resolve<ResetUserPermissionsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResetUserPermissionsResult>(null as any);
    }

    /**
     * Get All Users
     * @param filters (optional) 
     * @param sorting (optional) 
     * @return OK
     */
    getUsers(skipCount: number, maxResultCount: number, filters: string | undefined, sorting: string | undefined, signal?: AbortSignal): Promise<GetUsersResult> {
        let url_ = this.baseUrl + "/api/v1/identity/users?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (filters === null)
            throw new Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            url_ += "Filters=" + encodeURIComponent("" + filters) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUsers(_response);
        });
    }

    protected processGetUsers(response: AxiosResponse): Promise<GetUsersResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUsersResult.fromJS(resultData200);
            return Promise.resolve<GetUsersResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUsersResult>(null as any);
    }

    /**
     * Get User Permissions
     * @return OK
     */
    getUserPermissions(userid: number, signal?: AbortSignal): Promise<GetUserPermissionsResult> {
        let url_ = this.baseUrl + "/api/v1/identity/user/permissions/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserPermissions(_response);
        });
    }

    protected processGetUserPermissions(response: AxiosResponse): Promise<GetUserPermissionsResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUserPermissionsResult.fromJS(resultData200);
            return Promise.resolve<GetUserPermissionsResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUserPermissionsResult>(null as any);
    }

    /**
     * Get User By Id
     * @return OK
     */
    getUserById(userid: number, signal?: AbortSignal): Promise<GetUserByIdResult> {
        let url_ = this.baseUrl + "/api/v1/identity/user/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetUserById(_response);
        });
    }

    protected processGetUserById(response: AxiosResponse): Promise<GetUserByIdResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetUserByIdResult.fromJS(resultData200);
            return Promise.resolve<GetUserByIdResult>(result200);

        } else if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetUserByIdResult>(null as any);
    }

    /**
     * Delete User
     */
    deleteUser(userid: number, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/identity/user/{userid}";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined.");
        url_ = url_.replace("{userid}", encodeURIComponent("" + userid));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            signal
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 400) {
            const _responseText = response.data;
            let result400: any = null;
            let resultData400  = _responseText;
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthenticateRequest implements IAuthenticateRequest {
    usernameOrEmailAddress!: string | undefined;
    password!: string | undefined;

    constructor(data?: IAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }

    clone(): AuthenticateRequest {
        const json = this.toJSON();
        let result = new AuthenticateRequest();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateRequest {
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;
}

export class AuthenticateResponse implements IAuthenticateResponse {
    result!: AuthenticateResult;

    constructor(data?: IAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? AuthenticateResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthenticateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }

    clone(): AuthenticateResponse {
        const json = this.toJSON();
        let result = new AuthenticateResponse();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResponse {
    result: AuthenticateResult;
}

export class AuthenticateResult implements IAuthenticateResult {
    accessToken!: string | undefined;
    expireInSeconds!: number;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IAuthenticateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): AuthenticateResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }

    clone(): AuthenticateResult {
        const json = this.toJSON();
        let result = new AuthenticateResult();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResult {
    accessToken: string | undefined;
    expireInSeconds: number;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class CreateOrEditRoleDto implements ICreateOrEditRoleDto {
    id!: number | undefined;
    name!: string | undefined;
    isDefault!: boolean;
    grantedPermissions!: string[] | undefined;

    constructor(data?: ICreateOrEditRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrEditRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateOrEditRoleDto {
        const json = this.toJSON();
        let result = new CreateOrEditRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditRoleDto {
    id: number | undefined;
    name: string | undefined;
    isDefault: boolean;
    grantedPermissions: string[] | undefined;
}

export class CreateOrEditUserDto implements ICreateOrEditUserDto {
    id!: number | undefined;
    userName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    passportNo!: string | undefined;
    email!: string | undefined;
    password!: string | undefined;
    confirmPassword!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: ICreateOrEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.passportNo = _data["passportNo"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrEditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["passportNo"] = this.passportNo;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }

    clone(): CreateOrEditUserDto {
        const json = this.toJSON();
        let result = new CreateOrEditUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrEditUserDto {
    id: number | undefined;
    userName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    passportNo: string | undefined;
    email: string | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    roles: string[] | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    id!: number | undefined;
    name!: string | undefined;
    isDefault!: boolean;
    grantedPermissions!: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    id: number | undefined;
    name: string | undefined;
    isDefault: boolean;
    grantedPermissions: string[] | undefined;
}

export class CreateRoleResult implements ICreateRoleResult {
    role!: RoleDto;

    constructor(data?: ICreateRoleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateRoleResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateRoleResult {
        const json = this.toJSON();
        let result = new CreateRoleResult();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleResult {
    role: RoleDto;
}

export class CreateUserDto implements ICreateUserDto {
    id!: number | undefined;
    userName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    passportNo!: string | undefined;
    email!: string | undefined;
    password!: string | undefined;
    confirmPassword!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.passportNo = _data["passportNo"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["passportNo"] = this.passportNo;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    id: number | undefined;
    userName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    passportNo: string | undefined;
    email: string | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    roles: string[] | undefined;
}

export class CreateUserResult implements ICreateUserResult {
    user!: UserDto;

    constructor(data?: ICreateUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserResult {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateUserResult {
        const json = this.toJSON();
        let result = new CreateUserResult();
        result.init(json);
        return result;
    }
}

export interface ICreateUserResult {
    user: UserDto;
}

export class EditRoleDto implements IEditRoleDto {
    id!: number | undefined;
    name!: string | undefined;
    isDefault!: boolean;
    grantedPermissions!: string[] | undefined;

    constructor(data?: IEditRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): EditRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): EditRoleDto {
        const json = this.toJSON();
        let result = new EditRoleDto();
        result.init(json);
        return result;
    }
}

export interface IEditRoleDto {
    id: number | undefined;
    name: string | undefined;
    isDefault: boolean;
    grantedPermissions: string[] | undefined;
}

export class EditUserDto implements IEditUserDto {
    id!: number | undefined;
    userName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    passportNo!: string | undefined;
    email!: string | undefined;
    password!: string | undefined;
    confirmPassword!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: IEditUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.passportNo = _data["passportNo"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): EditUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["passportNo"] = this.passportNo;
        data["email"] = this.email;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }

    clone(): EditUserDto {
        const json = this.toJSON();
        let result = new EditUserDto();
        result.init(json);
        return result;
    }
}

export interface IEditUserDto {
    id: number | undefined;
    userName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    passportNo: string | undefined;
    email: string | undefined;
    password: string | undefined;
    confirmPassword: string | undefined;
    roles: string[] | undefined;
}

export class GetAllPermissionsResult implements IGetAllPermissionsResult {
    items!: PermissionGroupDto[] | undefined;

    constructor(data?: IGetAllPermissionsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionGroupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllPermissionsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPermissionsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllPermissionsResult {
        const json = this.toJSON();
        let result = new GetAllPermissionsResult();
        result.init(json);
        return result;
    }
}

export interface IGetAllPermissionsResult {
    items: PermissionGroupDto[] | undefined;
}

export class GetCurrentSessionResult implements IGetCurrentSessionResult {
    user!: UserLoginInfoDto;
    allPermissions!: { [key: string]: boolean; } | undefined;
    grantedPermissions!: { [key: string]: boolean; } | undefined;

    constructor(data?: IGetCurrentSessionResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            if (_data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in _data["allPermissions"]) {
                    if (_data["allPermissions"].hasOwnProperty(key))
                        (<any>this.allPermissions)![key] = _data["allPermissions"][key];
                }
            }
            if (_data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in _data["grantedPermissions"]) {
                    if (_data["grantedPermissions"].hasOwnProperty(key))
                        (<any>this.grantedPermissions)![key] = _data["grantedPermissions"][key];
                }
            }
        }
    }

    static fromJS(data: any): GetCurrentSessionResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentSessionResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    (<any>data["allPermissions"])[key] = (<any>this.allPermissions)[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    (<any>data["grantedPermissions"])[key] = (<any>this.grantedPermissions)[key];
            }
        }
        return data;
    }

    clone(): GetCurrentSessionResult {
        const json = this.toJSON();
        let result = new GetCurrentSessionResult();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentSessionResult {
    user: UserLoginInfoDto;
    allPermissions: { [key: string]: boolean; } | undefined;
    grantedPermissions: { [key: string]: boolean; } | undefined;
}

export class GetRoleByIdResult implements IGetRoleByIdResult {
    role!: CreateOrEditRoleDto;

    constructor(data?: IGetRoleByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? CreateOrEditRoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRoleByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetRoleByIdResult {
        const json = this.toJSON();
        let result = new GetRoleByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetRoleByIdResult {
    role: CreateOrEditRoleDto;
}

export class GetRolesResult implements IGetRolesResult {
    items!: RoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetRolesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetRolesResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetRolesResult {
        const json = this.toJSON();
        let result = new GetRolesResult();
        result.init(json);
        return result;
    }
}

export interface IGetRolesResult {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class GetUserByIdResult implements IGetUserByIdResult {
    user!: CreateOrEditUserDto;

    constructor(data?: IGetUserByIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? CreateOrEditUserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUserByIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserByIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetUserByIdResult {
        const json = this.toJSON();
        let result = new GetUserByIdResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserByIdResult {
    user: CreateOrEditUserDto;
}

export class GetUserPermissionsResult implements IGetUserPermissionsResult {
    items!: string[] | undefined;

    constructor(data?: IGetUserPermissionsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item);
        }
        return data;
    }

    clone(): GetUserPermissionsResult {
        const json = this.toJSON();
        let result = new GetUserPermissionsResult();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsResult {
    items: string[] | undefined;
}

export class GetUsersResult implements IGetUsersResult {
    items!: UserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGetUsersResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetUsersResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetUsersResult {
        const json = this.toJSON();
        let result = new GetUsersResult();
        result.init(json);
        return result;
    }
}

export interface IGetUsersResult {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class OAuthAuthenticateRequest implements IOAuthAuthenticateRequest {
    code!: string | undefined;
    redirectUri!: string | undefined;

    constructor(data?: IOAuthAuthenticateRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.redirectUri = _data["redirectUri"];
        }
    }

    static fromJS(data: any): OAuthAuthenticateRequest {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAuthenticateRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["redirectUri"] = this.redirectUri;
        return data;
    }

    clone(): OAuthAuthenticateRequest {
        const json = this.toJSON();
        let result = new OAuthAuthenticateRequest();
        result.init(json);
        return result;
    }
}

export interface IOAuthAuthenticateRequest {
    code: string | undefined;
    redirectUri: string | undefined;
}

export class OAuthAuthenticateResponse implements IOAuthAuthenticateResponse {
    result!: OAuthAuthenticateResult;

    constructor(data?: IOAuthAuthenticateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? OAuthAuthenticateResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OAuthAuthenticateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAuthenticateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }

    clone(): OAuthAuthenticateResponse {
        const json = this.toJSON();
        let result = new OAuthAuthenticateResponse();
        result.init(json);
        return result;
    }
}

export interface IOAuthAuthenticateResponse {
    result: OAuthAuthenticateResult;
}

export class OAuthAuthenticateResult implements IOAuthAuthenticateResult {
    accessToken!: string | undefined;
    expireInSeconds!: number;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IOAuthAuthenticateResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): OAuthAuthenticateResult {
        data = typeof data === 'object' ? data : {};
        let result = new OAuthAuthenticateResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }

    clone(): OAuthAuthenticateResult {
        const json = this.toJSON();
        let result = new OAuthAuthenticateResult();
        result.init(json);
        return result;
    }
}

export interface IOAuthAuthenticateResult {
    accessToken: string | undefined;
    expireInSeconds: number;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class PermissionDto implements IPermissionDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isGranted!: boolean;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isGranted = _data["isGranted"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isGranted"] = this.isGranted;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    isGranted: boolean;
}

export class PermissionGroupDto implements IPermissionGroupDto {
    groupName!: string | undefined;
    permissions!: PermissionDto[] | undefined;

    constructor(data?: IPermissionGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.groupName = _data["groupName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupName"] = this.groupName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionGroupDto {
        const json = this.toJSON();
        let result = new PermissionGroupDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionGroupDto {
    groupName: string | undefined;
    permissions: PermissionDto[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type!: string | undefined;
    title!: string | undefined;
    status!: number | undefined;
    detail!: string | undefined;
    instance!: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }

    clone(): ProblemDetails {
        const json = this.toJSON();
        let result = new ProblemDetails();
        result.init(json);
        return result;
    }
}

export interface IProblemDetails {
    type: string | undefined;
    title: string | undefined;
    status: number | undefined;
    detail: string | undefined;
    instance: string | undefined;

    [key: string]: any;
}

export class RefreshTokenRequest implements IRefreshTokenRequest {
    token!: string | undefined;

    constructor(data?: IRefreshTokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): RefreshTokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }

    clone(): RefreshTokenRequest {
        const json = this.toJSON();
        let result = new RefreshTokenRequest();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenRequest {
    token: string | undefined;
}

export class RefreshTokenResponse implements IRefreshTokenResponse {
    result!: RefreshTokenResult;

    constructor(data?: IRefreshTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"] ? RefreshTokenResult.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RefreshTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        return data;
    }

    clone(): RefreshTokenResponse {
        const json = this.toJSON();
        let result = new RefreshTokenResponse();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenResponse {
    result: RefreshTokenResult;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }

    clone(): RefreshTokenResult {
        const json = this.toJSON();
        let result = new RefreshTokenResult();
        result.init(json);
        return result;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    expireInSeconds: number;
}

export class ResetUserPermissionsResult implements IResetUserPermissionsResult {

    constructor(data?: IResetUserPermissionsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): ResetUserPermissionsResult {
        data = typeof data === 'object' ? data : {};
        let result = new ResetUserPermissionsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): ResetUserPermissionsResult {
        const json = this.toJSON();
        let result = new ResetUserPermissionsResult();
        result.init(json);
        return result;
    }
}

export interface IResetUserPermissionsResult {
}

export class RoleDto implements IRoleDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    name!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    isAssigned!: boolean;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.isAssigned = _data["isAssigned"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["isAssigned"] = this.isAssigned;
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    name: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    isAssigned: boolean;
}

export class UpdateRoleResult implements IUpdateRoleResult {
    role!: RoleDto;

    constructor(data?: IUpdateRoleResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateRoleResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateRoleResult {
        const json = this.toJSON();
        let result = new UpdateRoleResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateRoleResult {
    role: RoleDto;
}

export class UpdateUserPermissionsResult implements IUpdateUserPermissionsResult {

    constructor(data?: IUpdateUserPermissionsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): UpdateUserPermissionsResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }

    clone(): UpdateUserPermissionsResult {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsResult {
}

export class UpdateUserResult implements IUpdateUserResult {
    user!: UserDto;

    constructor(data?: IUpdateUserResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateUserResult {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateUserResult {
        const json = this.toJSON();
        let result = new UpdateUserResult();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserResult {
    user: UserDto;
}

export class UserDto implements IUserDto {
    id!: number;
    creatorUser!: string | undefined;
    creatorUserId!: number | undefined;
    creationTime!: moment.Moment;
    lastModifierUser!: string | undefined;
    lastModifierUserId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    userName!: string | undefined;
    firstName!: string | undefined;
    lastName!: string | undefined;
    passportNo!: string | undefined;
    email!: string | undefined;
    roles!: string[] | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creatorUser = _data["creatorUser"];
            this.creatorUserId = _data["creatorUserId"];
            this.creationTime = _data["creationTime"] ? moment(_data["creationTime"].toString()) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"];
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? moment(_data["lastModificationTime"].toString()) : <any>undefined;
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.passportNo = _data["passportNo"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creatorUser"] = this.creatorUser;
        data["creatorUserId"] = this.creatorUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["passportNo"] = this.passportNo;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    creatorUser: string | undefined;
    creatorUserId: number | undefined;
    creationTime: moment.Moment;
    lastModifierUser: string | undefined;
    lastModifierUserId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    userName: string | undefined;
    firstName: string | undefined;
    lastName: string | undefined;
    passportNo: string | undefined;
    email: string | undefined;
    roles: string[] | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id!: number;
    firstName!: string | undefined;
    lastName!: string | undefined;
    userName!: string | undefined;
    email!: string | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    firstName: string | undefined;
    lastName: string | undefined;
    userName: string | undefined;
    email: string | undefined;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}